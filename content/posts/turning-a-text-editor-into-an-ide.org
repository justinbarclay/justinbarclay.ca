#+TITLE: Turning A Text Editor Into An IDE
#+date: <2023-12-11 Mon>
#+author: Justin Barclay
#+description: Using Emacs' built in funcitonality to get code completion and more
#+section: ./posts
#+weight: 2001
#+auto_set_lastmod: t
#+draft: false
#+tags[]: emacs code-completion diagnostics eglot flymake

@@html:<div class="banner-image" height="500px">@@
@@html:<img style="height:700px" alt="Be the change you want to see." src="/ox-hugo/two-people-configuring-emacs.webp"/>@@
@@html:</div>@@


With version 29, [[id:c384a986-2a40-44fa-86b3-4143385b0a58][Emacs]] completed made great strides to giving the user the ability to craft their own IDE, using only built-in packages. Of course, this has been a long time coming. It started off with the update of Flymake in Emacs 26, Flymake is a built in linting and diagnostic framework. The journey has reached it's zenith with Emacs' getting a built in support for [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]] with [[https://github.com/joaotavora/eglot][Eglot]]. So now, I would like to see how close Emacs can get to an IDE like experience.

But what does it mean to be IDE like?

We'll use [[https://code.visualstudio.com/learn][Vs Code]] as our gold standard. To find out what features make it special, we'll see what Microsoft's calls out as important to it's users as found on its [[https://code.visualstudio.com/learn][learn]] page:
#+begin_quote
Visual Studio Code is a free coding editor that helps you start coding quickly. Use it to code in any programming language, without switching editors. Visual Studio Code has support for many languages, including Python, Java, C++, JavaScript, and more.
#+end_quote

Ok, so to start with we need built in support for popular programming languages. For my example, I am going to build an IDE for Ruby, but one could imagine it is trivial to expand the functionality to any of the languages mentioned above.

#+begin_quote
  ### Collaborate and code remotely

  Work together remotely with your teachers or classmates using the free Live Share extension. Edit and debug your code in real-time, and use the chat and call features to ask questions or discuss ideas together.
#+end_quote

This one I'll have to skip. Emacs aims to be a local first code editor with no reliance on external systems or services... and well Live Share requires someone spend lots of money to maintain servers. Well outside of Emacs' wheelhouse, so I'll just take the L here.

#+begin_quote

  ### Code to learn

  New to coding? Visual Studio Code highlights keywords in your code in different colors to help you easily identify coding patterns and learn faster. You can also take advantage of features like IntelliSense and Peek Definition
#+end_quote
So, to clarify our language support should include syntax highlighting and some sort of [[https://en.wikipedia.org/wiki/Intelligent_code_completion][intellisense]] capabilities.
#+begin_quote
  ### Fix errors as you code

  As you code, Visual Studio Code gives you suggestions to complete lines of code and quick fixes for common mistakes.
#+end_quote

And then we'll need a [[https://www.perforce.com/blog/qac/what-lint-code-and-what-linting-and-why-linting-important][linter]].

#+begin_quote
  You can also use the debugger in VS Code to step through each line of code and understand what is happening. Check out guides on how to use the debugger if you're coding in Python, Java, and JavaScript/TypeScript/Node.js.
#+end_quote

While Emacs' does have a built in debugger for a variety of [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Starting-GUD.html][debuggers]], it doesn't natively support Ruby, so that's another L.

#+begin_quote
  ### Make it yours with custom themes and colors

  You can change the look and feel of VS Code by picking your favorite fonts and icons and choosing from hundreds of color themes. Check out this video on personalizing VS Code.
#+end_quote

We should be able to make Emacs look pretty.

#+begin_quote
  ### Compare changes in your code

  Use the built-in source control to save your work over time so you don't lose progress. See a graphical side-by-side view to compare versions of your code from different points in time. Check out this quick video on how to get a side-by-side "diff".
#+end_quote

Finally, we should be able to get diffs of the changes we make and we should also support version control.

So to summarize our IDE should:
1. Support editing in major languages:
   - Have syntax highlighting
   - Have code diagnostics
   - Have intellisense
2. Make Emacs look pretty
3. Built in support for version control
   - including built in support for seeing changes made (diffing)

* In The Beginning...
...there was [[https://jwiegley.github.io/use-package/][use-package]]. ~use-package~ is a lisp [[https://wiki.c2.com/?LispMacro][macro]] that allows you to declaratively configure Emacs and it's libraries and it's packages. ~use-package~ is a package that has been around for over [[https://github.com/jwiegley/use-package/commit/7ee0fcd0a09c2934e77bf5702e75ba4acba4299c][10 years]]. And it has gain such a foothold into the Emacs community that it landed in Emacs core for the release of [[https://www.gnu.org/software/emacs/manual/html_node/efaq/New-in-Emacs-29.html#:~:text=Emacs%20comes%20with%20the%20popular%20use-package][Emacs 29]].

For example:
#+begin_src elisp
(use-package emacs
 :ensure nil
 :init
 (load-theme 'some-theme))
#+end_src

Reading the above snippet of code says that when emacs is initialized, ~:init~, to load the theme ~some-theme~. The ~:ensure~ keyword then tells Emacs' not to download from the package repositories defined in ~package-archives~. ~use-package~ can do a lot more, but you'll have to read elsewhere for that.

* TODO Lipstick on a Pig 
I'm a shallow person, and I am sure you are too. I find it hard to use something when it looks ugly. The motivation just isn't there. So let's fix that. Unfortunately, we're a bit limited, Emacs only has a handful of themes and none of them are particularly beautiful.

** Themes
- adwaita
- deeper-blue
- dichromacy 	
- leuven
- leuven-dark 	
- light-blue
- manoj-dark 	
- misterioso
- modus-operandi 	
- modus-operandi-deuteranopia
- modus-operandi-tinted 	
- modus-operandi-tritanopia
- modus-vivendi 	
- modus-vivendi-deuteranopia
- modus-vivendi-tinted 	
- modus-vivendi-tritanopia
- tango 	
- tango-dark
- tsdh-dark 	
- tsdh-light
- wheatgrass 	
- whiteboard
- wombat
** Facing the Music
Programming fonts are a very personal choice, and if you're like me, your personal choice is very rarely the system default font. You can change the default font by using [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Attribute-Functions.html#index-set_002dface_002dattribute][set-face-attribute]]. Where [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Faces.html][face]], is kind of like a CSS Class. It's a named collection of graphical attributes for display, ~default~ in our case, that contains information on what font to render and how it should look. This functions takes in a set of arguments, the name of the face, what frame this face should be applied to it, and the list of attributes to apply the face. We only really care about setting the ~font~ and ~height~ attributes for the ~default~ face. If you want to further refine the look you can find all the face attributes [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Face-Attributes.html][here]].

#+begin_src elisp 
  ;; (set-face-attribute face frame &rest arguments)
  (use-package emacs
  ;;...
    :init
    (load-theme 'wombat)
    (set-face-attribute 'default nil :font "CaskaydiaCove Nerd Font Mono" :height 160))
#+end_src

*** Further reading
- How attributes are [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Displaying-Faces.html][set]]
** TODO-List
- [ ] Add colour palettes for each built in theme
  
#+begin_src emacs-lisp
  (require 'svg)
  (setq svg (svg-create 800 800 :stroke "black" :stroke-width 5))
  (svg-gradient svg "gradient" 'linear '((0 . "red") (100 . "red")))
  (save-excursion (goto-char (point-max)) (svg-insert-image svg))
  (svg-rectangle svg 100 100 500 500 :gradient "gradient" :id "rec1")
  (defun svg-square (color)
    (svg-rectangle svg
                   0 0 100 100
                    :fill color))
  (svg-square "red")
#+end_src
** Other minor UI tweaks
I find the scrollbars in Emacs to look Garish, so I would much rather hide them. But, we also have to ensure that Emacs' is loaded with scrollbars or we could error out when running on the command line, so we check with ~fboundp~.
#+begin_src elisp
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
#+end_src

I find the toolbar takes up a lot of space and doesn't add much to the equation if we keep the menu-bar in play, so I also disable that.
#+begin_src elisp
(tool-bar-mode -1)
#+end_src


** Putting it all together
#+begin_src elisp :tangle /tmp/emacs/init.el
  (use-package emacs
    :init
    (tool-bar-mode -1)
    (when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
    (load-theme 'wombat)
    (set-face-attribute 'default nil :font "CaskaydiaCove Nerd Font Mono" :height 160)
    :custom
    (treesit-language-source-alist
     '((ruby "https://github.com/tree-sitter/tree-sitter-ruby"))))
#+end_src
* Major Modes and Highlighting
Now that things are looking better, let's learn how to customize [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Major-Modes.html][major modes]]. A major mode describes the behaviour associated with a buffer. For buffers related to source code files this behaviour is generally syntax highlight, cursor movement, and some default keybindings/interaction. ~ruby-ts-mode~ is Emacs' major mode that utilizes [[https://tree-sitter.github.io/tree-sitter/][tree-sitter]] for syntax-highlighting.

Most major-modes in Emacs that are tree-sitter based have ~-ts-~ within the name. So theoretically you could call ~ruby-ts-mode~ and have tree-sitter based ruby syntax highlighting for your files. 
#+begin_src elisp
  (use-package ruby-ts-mode
    :mode "\\.rb\\'"
    :mode "Rakefile\\'"
    :mode "Gemfile\\'")
#+end_src

#+begin_quote
I use mode here to specify which file types should be controlled by the ~ruby-ts-mode~. In this example, any file ending in ".rb" and any file called "Rakefile" or "Gemfile" should activate the ruby-ts major mode.
#+end_quote

** Installing a treesitter grammer
Unfortunately, using a tree-sitter major-mode is not quite that simple. Although, Emacs can utilize tree sitter grammar and parsers, it does not install them for you. Instead, you need to create an assign [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][alist]] to treesit-language-source-alist. This alist should be language and git repo of the tree-sitter parsers.

So, for just ruby that would look like
#+begin_src elisp :tangle /tmp/emacs/init.el
  (use-package emacs
    ;;...
    :custom
    (treesit-language-source-alist
     '((ruby "https://github.com/tree-sitter/tree-sitter-ruby"))))
#+end_src

And then you need to run the command ~treesit-install-language-grammar~ and select the language you want to install.

For a more in depth look into how to setup tree-sitter for Emacs 29, see [[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter][Mickey Peterson's article]].

** Bindings
Now that we have a working ts-mode, what else does Emacs do for us? Well for ruby, and many other languages, it will also add keybindings to simplify common operations.

Alongside Emacs' regular keybindings, see the [[https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf][cheatsheet]], ~ruby-ts-mode~ adds the following keybindings

| Key Bindings | Interactive function      | Description                                                    |
|--------------+---------------------------+----------------------------------------------------------------|
| C-M-q        | prog-indent-sexp          | Indent the expression after point.                             |
| C-c '        | ruby-toggle-string-quotes | Toggle string literal quoting between single and double.       |
| C-c C-f      | ruby-find-library-file    | Visit a library file denoted by FEATURE-NAME.                  |
| C-c {        | ruby-toggle-block         | Toggle block type from do-end to braces or back.               |
| M-q          | prog-fill-reindent-defun  | Refill or reindent the paragraph or defun that contains point. |

You can see this for yourself by pressing ~C-h m~ or ~M-x describe-mode~.

You can also set some key bindings yourself. For instance what about jumping to the beginning and end of functions? Here, I use ~C-c~ because that is the common prefix for user key bindings, then I use ~r~ for ruby, and then finally ~b~ for beginning and ~e~ for end of defun.
#+begin_src elisp
  (define-key ruby-ts-mode-map (kbd "C-c r b") 'treesit-beginning-of-defun)
  (define-key ruby-ts-mode-map (kbd "C-c r e") 'treesit-end-of-defun)
#+end_src

Or you can use bind-key to simplify this.
#+begin_src elisp
  (use-package bind-key)
  
  (use-package ruby-ts-mode
    :bind (:map ruby-ts-mode-map
                ("C-c r b" . 'treesit-beginning-of-defun)
                ("C-c r e" . 'treesit-end-of-defun))
    ;;...
    )
#+end_src

And if you forget what these key chords, or any key chords, do you can use ~C-h k~ to describe a key chord. For example, pressing ~C-h k~ + ~C-c r b~ in ~ruby-ts-mode~ opens up a buffer saying

#+begin_quote
ruby-beginning-of-defun is an interactive and natively compiled function defined in ruby-mode.el.gz
#+end_quote
** Customizing Ruby Mode
To find a complete list of customizable attributes for ~ruby-ts-mode~ you can search by customize-group using ~M-x customize-group RET ruby RET~.
But for now we'll just focus on white-space:

#+begin_src elisp
  (use-package ruby-ts-mode
    ;;...
    :custom
    (ruby-indent-level 2)
    (ruby-indent-tabs-mode nil))
#+end_src

You can also tell Emacs to enable minor modes like [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html][subword-mode]] when your major mode starts up. All define a cons cell of the major-minor mode pairs  ~(major-mode . minor-mode)~ alongside the ~:hook~ keyword
#+begin_src elisp
  (use-package ruby-ts-mode
    :hook (ruby-ts-mode . subword-mode))
#+end_src

#+begin_quote
The subword minor mode replaces the basic word oriented movement and editing commands with variants that recognize subwords in [words with mixed upper and lowercase characters] and treat them as separate words
#+end_quote
** Putting it all together
With those tweaks and adjustments we can define our ruby config like so:
#+begin_src elisp :tangle /tmp/emacs/init.el
  (use-package ruby-ts-mode
    :mode "\\.rb\\'"
    :mode "Rakefile\\'"
    :mode "Gemfile\\'"
    :hook (ruby-ts-mode . subword-mode)
    :bind (:map ruby-ts-mode-map
                ("C-c r b" . 'treesit-beginning-of-defun)
                ("C-c r e" . 'treesit-end-of-defun))
    :custom
    (ruby-indent-level 2)
    (ruby-indent-tabs-mode nil))
#+end_src
* Codes sense and completion
[[https://microsoft.github.io/language-server-protocol/][Language Servers]] have becomes the industry standard for getting [[https://en.wikipedia.org/wiki/Intelligent_code_completion][intellisense]] like behaviour from your editor. And, with the release of version 29, Emacs has built-in support for LSP with [[https://www.gnu.org/software/emacs/manual/html_node/eglot/index.html][Eglot]], which stands Emacs Polyglot.

Some of the features Eglot [[https://www.gnu.org/software/emacs/manual/html_node/eglot/Eglot-Features.html][provides]]:
- At-point documentation
- On-the-fly diagnostic annotations
- Finding definitions and uses of identifiers
- Buffer navigation
- completion of symbol at point
- automatic code formatting
- integration with popular third-party packages including [[https://github.com/joaotavora/yasnippet][yasnippet]], [[https://github.com/jrblevin/markdown-mode][markdown-mode]], [[https://github.com/company-mode/company-mode][company-mode]] or [[https://github.com/minad/corfu][corfu]].

Luckily Eglot is easy to set-up. We can use the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Major-Modes.html][prog-mode-hook]] and Eglot's ~eglot-ensure~ function to attempt to start a language server for all programming related buffers.

#+begin_quote
Prog mode is a basic major mode for buffers containing programming language source code. Most of the programming language major modes built into Emacs are derived from it.
#+end_quote

#+begin_src elisp
  (use-package eglot
    :hook (prog-mode . eglot-ensure))
#+end_src

Eglot comes with several of [[https://www.gnu.org/software/emacs/manual/html_node/eglot/Eglot-Features.html][features]] and some of these features integrate with other libraries/packages of Emacs. Below, I've outlined the features of Eglot that I'm going to use and the library dependency, if any, it relies on.

| Feature                        | Dependency          |
|--------------------------------+---------------------|
| complete symbol at point       | [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html][completion-at-point]] |
| code formatting                |                     |
| At-point documentation         | [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Programming-Language-Doc.html][eldoc]]               |
| on-the-fly eglot--diagnostics  | [[https://www.gnu.org/software/emacs/manual/html_node/flymake/index.html#Top][flymake]]             |
| buffer-navigation              | [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html][imenu]]               |
| jump to definition/find useage | [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html][xref]]                |

** Adding Documentation
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Programming-Language-Doc.html][Eldoc]], which started out as ~emacs-lips documentation~, is Emacs' documentation library. When it's enabled it shows either the function's documentation, or barring that, the argument list for the function in the echo area. However, this documentation is only limited to a line or two of information. If you want the full document that Emacs' has for that function, class, or method then Emacs give you ~display-local-help~, which is bound to ~C-h .~.

In general, I think it's best to enable ~eldoc~ everywhere
#+begin_src elisp :tangle /tmp/emacs/init.el
(use-package eldoc
  :init
  (global-eldoc-mode))
#+end_src
** Other riffraff
Eldoc requires _some_ configuration to work these other ones don't - they just have keybindings that aren't explained to you.

| Systems             | Keybindings | Description                                                                                     |
|---------------------+-------------+-------------------------------------------------------------------------------------------------|
| [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html][iMenu]]               | ~M-g i~     | a system that uses [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]] used for jumping to major definitions or sections of a file. |
| [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html][xref]]                |             | Is an ancient system that finds references and definitions for a major mode's indentifiers.     |
|                     | ~M-.~       | Jump to the definition of the symbol at point                                                   |
|                     | ~M-,~       | Jump back to the last location that invoke ~M-.~                                                |
| [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html][completion-at-point]] | ~M-<TAB>~   | Pops up possible completions for the symbol at point                                            |


** Bindings
Eglot comes with a lot of built-in functions and I think some of them should be elevated to the status of keybinding.
#+begin_src elisp
(use-package eglot
    ;;.
    :bind (:map
           eglot-mode-map
           ("C-c c a" . 'eglot-code-actions)
           ("C-c c o" . 'eglot-code-actions-organize-imports)
           ("C-c c r" . 'eglot-rename)
           ("C-c c f" . 'eglot-format)))
#+end_src

** Criticisms
I think Emacs' built-in in-buffer completion system is still it's weakest point. It lags behind all other major text editos which provide completions as you type and it provides those completions in a pop-up beside your cursor. Meanwhile Emacs' will only show you potential completions when you hit ~M-<TAB>~ and it shows completions outside of your current one. This feels non-ergonomic, and the community agrees with me. They're have been at least [[https://github.com/auto-complete/auto-complete][3]] [[https://github.com/company-mode/company-mode][pop-up]] [[https://github.com/minad/corfu][completion]] frameworks for Emacs and I hope that one day soon Emacs settles on one.

*** A minor fix
Emacs doesn't come with a pop-up library. But we can use the magic of [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Timers.html][timers]] and [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html][advice]] to fix the autocomplete problem.
#+begin_src elisp
  (defvar complete-at-point--timer nil "Timer for triggering complete-at-point.")

  (defun auto-complete-at-point (&rest _)
    "Set a time to complete the current symbol at point in 0.1 seconds"
    (when (and (not (minibufferp)))
      (when (timerp complete-at-point--timer)
        (cancel-timer complete-at-point--timer))
      (setq complete-at-point--timer
            (run-at-time 0.1 nil-blank-string
                         (lambda ()
                           (when (timerp complete-at-point--timer)
                             (cancel-timer complete-at-point--timer))
                           (setq complete-at-point--timer nil)
                           (completion-at-point))))))

  (advice-add 'self-insert-command :after #'auto-complete-at-point)
#+end_src

Now of course, if you are one that only wants to completions to pop-up at your behest you can ignore the above code block and use ~M-<TAB>~ to your hearts content.
** Completing our completing read
#+begin_src elisp :tangle /tmp/emacs/init.el
  (use-package eglot
    :hook (prog-mode . eglot-ensure)
    ;; The first 5 bindings aren't needed here, but are a good
    ;; reminder of what they are bound too
    :bind (("M-TAB" . completion-at-point)
           ("M-g i" . imenu)
           ("C-h ." . display-local-help)
           ("M-." . xref-find-definitions)
           ("M-," . xref-go-back)
           :map
           eglot-mode-map
           ("C-c c a" . 'eglot-code-actions)
           ("C-c c o" . 'eglot-code-actions-organize-imports)
           ("C-c c r" . 'eglot-rename)
           ("C-c c f" . 'eglot-format))
    :config
    (defvar complete-at-point--timer nil "Timer for triggering complete-at-point.")

    (defun auto-complete-at-point (&rest _)
      "Set a time to complete the current symbol at point in 0.1 seconds"
      (when (and (not (minibufferp)))
        ;; If a user inserts a character while a timer is active, reset
        ;; the current timer
        (when (timerp complete-at-point--timer)
          (cancel-timer complete-at-point--timer))
        (setq complete-at-point--timer
              (run-at-time 0.2 nil
                           (lambda ()
                             ;; Clear out the timer and run
                             ;; completion-at-point
                             (when (timerp complete-at-point--timer)
                               (cancel-timer complete-at-point--timer))
                             (setq complete-at-point--timer nil)
                             (completion-at-point))))))
    ;; Add a hook to enable auto-complete-at-point when eglot is enabled
    ;; this allows use to remove the hook on 'post-self-insert-hook if
    ;; eglot is disabled in the current buffer
    (add-hook 'eglot-managed-mode-hook (lambda ()
                                         (if eglot--managed-mode
                                             (add-hook 'post-self-insert-hook #'auto-complete-at-point nil t)
                                           (remove-hook 'post-self-insert-hook #'auto-complete-at-point t)))))
#+end_src
* Linting and Error checking
Emacs has a built-in on-the-fly syntax checker called [[https://www.gnu.org/software/emacs/manual/html_node/flymake/index.html#Top][Flymake]].

By default, Flymake supports 10 languages including Ruby. Specifically, it's supports using either [[https://rubocop.org/][Rubocop]] or the ruby CLI itself, through ~ruby -w -c~. Like with ~ruby-ts-mode~ we will use ~use-package~ to load and configure the package. Now, we could tell Flymake only start up when ~ruby-ts-mode~ starts up with ~:hook (ruby-ts-mode . flymake-mode)~. However, that means we'll have to add to this list each time we want to add Flymake to a new language. Instead, we could tell Flymake to add itself to the prog-mode-hook ~:hook (prog-mode . flymake-mode)~, thus ensuring that Flymake tries to start-up for every programming related buffer.

#+begin_src elisp
(use-package flymake
  :hook (prog-mode . flymake-mode))
#+end_src

Now, you're buffers will light up a Christmas tree and yell at your for all of the mistakes you're making. Flymake, comes with a couple functions for understanding your errors and for navigating your mistakes.
  - flymake-goto-next-error
  - flymake-goto-prev-error
  - flymake-show-buffer-diagnostics

Unfortunately, none of these are bound to key chords. But we can fix that!
#+begin_src elisp :tangle /tmp/emacs/init.el
  (use-package flymake
    :hook (prog-mode . flymake-mode)
    ;; This first bind conflicts with eglot, but is left here for
    ;; demonstrative purposes
    :bind (("C-h ." . display-local-help)
          :map flymake-mode-map
          ("C-c ! n" . flymake-goto-next-error)
          ("C-c ! p" . flymake-goto-prev-error)
          ("C-c ! l" . flymake-show-diagnostics-buffer)))
#+end_src

* Version Control
Like imenu and xref, Emacs' Version Control system, [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Version-Control.html][~vc.el~]], is built-in and enabled by default. ~vc.el~ has been around for many years and as such has accumulated support for _bunch_ of version control systems.
- [[https://en.wikipedia.org/wiki/Git][Git]]
- [[https://en.wikipedia.org/wiki/Concurrent_Versions_System][CVS]]
- [[https://en.wikipedia.org/wiki/Apache_Subversion][Subversion]]
- [[https://en.wikipedia.org/wiki/Source_Code_Control_System][SCCS]]
- [[https://en.wikipedia.org/wiki/Source_Code_Control_System#GNU_conversion_utility][CSSC]]
- [[https://en.wikipedia.org/wiki/Revision_Control_System][RCS]]
- [[https://en.wikipedia.org/wiki/Mercurial][Mercurial]]
- [[https://en.wikipedia.org/wiki/GNU_Bazaar][Bazaar]]
- [[http://www.catb.org/~esr/src/][SRC]]

For a system like git you can use ~M-x vc-dir~ (~C-x v d RET~) to view the status of the current directory. If you're looking to diff things Emacs gives you ~M-x vc-root-diff~ (~C-x v D~) to diff the entire repository or ~M-x vc-diff~ (~C-x v =~) to diff the current file.

If you're looking to commit the changes for a file you can use ~M-x vc-next-action~ (~C-x v v~), which will stage your current changes and prompt you to enter your commit message. Then, when you're done you hit ~C-c C-c~.

You don't need to add ~vc~ your config file, but it may help to have some reminders for the keybindings
#+begin_src emacs-lisp
  (use-package vc
    ;; This is not needed but it is left here as a reminder of some of the keybindings
    :bind (("C-x v d" vc-dir)
           ("C-x v =" vc-diff)
           ("C-x v D" vc-root-diff)
           ("C-x v v" vc-next-action))
#+end_src

I'm not here to walk you through how to use ~vc~, my intent was to show you that it existed and what, if any, config is needed.

** Conflicts
I'd be remiss if I did not point out Emacs' two systems for dealing with merge conflict. You have access to ~smerge~, which stands for simple merge, that lets you put your cursor within the conflict and choose to keep the top, bottom or both.

#+begin_src elisp
  (use-package smerge-mode
    :bind (:map smerge-mode-map
                ("C-c ^ u" . smerge-keep-upper)
                ("C-c ^ l" . smerge-keep-lower)
                ("C-c ^ n" . smerge-next)
                ("C-c ^ p" . smerge-previous)))
#+end_src

Or there is [[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html][ediff]], which is outside of the scope of this article to explain how to use.
